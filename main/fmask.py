"""
Author: Shi Qiu, Zhe Zhu
Email: shi.qiu@uconn.edu, zhe@uconn.edu
Affiliation: University of Connecticut
Date: 2025-10-23
Version: 5.0.1
License: MIT

Website: https://github.com/gersl/fmask

Description:
Fmask 5 is an open-source package designed to detect clouds and cloud shadows in imagery from Landsat 4, 5, 7, 8, and 9, as well as Sentinel-2 A, B, and C.

Fmask 5 provides seven cloud detection models:
- PHY: Physical (i.e., Fmask 4.6) (CPU)
- GBM: LightGBM (CPU)
- UNT: U-Net (CPU and GPU)
- LPL: LightGBM-Physical-LightGBM (CPU; recommended for Landsats 4-7)
- UPU: U-Net-Physical-U-Net (GPU only)
- LPU: LightGBM-Physical-U-Net (GPU only)
- UPL: U-Net-Physical-LightGBM (CPU; recommended for Landsats 8-9 and Sentinel 2)

Fmask 5 detects cloud shadows using a physical model, similar to Fmask 4.6, with the following modifications:

The cloud shadow detection is based on the physical model. The physical model is the same as Fmask 4.6,except that
- A 5-pixel dilation is made at default for filling potential holes generated by the cloud projection,especially when a DEM is integrated to account for double projections. (the version eailser 4.6 uses 3-pixel dilation at default; see Zhu et al, 2012).
- The maxinum sampling cloud pixels is 60,000 (the version eailser 4.6 uses 1000,000 at default). This new setting was determined based on the sensituvety test of the cloud shadow reference of L8-Biome, and the reduced samples can improve the computational efficiency with no significant impact on the final results.
- CSC topographic correction (see Qiu et al, 2019; RS) is used instead of the CSC+C correction, improving computational efficiency with no significant impact on final results.

Usage examples:
- python fmask.py --model=UPL --dcloud=0 --dshadow=5 --imagepath='/gpfs/sharedfs1/zhulab/Shi/ProjectCloudDetectionFmask5/HLSDataset/LC08_L1TP_048022_20230713_20230724_02_T1'
- python fmask.py --model=UPL --dcloud=0 --dshadow=5 --imagepath='/gpfs/sharedfs1/zhulab/Shi/ProjectCloudDetectionFmask5/HLSDataset/S2B_MSIL1C_20250117T183619_N0511_R027_T11SLT_20250117T221425.SAFE'

Command-line arguments:
--model: the Fmask cloud detection model to use (PHY, GBM, UNT, LPL, UPU, LPU, UPL)
--dcloud: dilation for cloud mask in pixels; default is 0
--dshadow: dilation for shadow mask in pixels; default is 5
--dsnow: dilation for snow mask in pixels; default is 0
--output: destination directory for results; if not provided, results are saved in the image's directory
--skip_existing: skip processing the image when its fmask layer exists; default is 'no'
--save_metadata: save the model metadata to a CSV file; default is 'no'
--display_fmask: display the Fmask result and save it as a PNG file; default is 'no'
--display_image: display the color composite images (NIR-Red-Green and SWIR1-NIR-Red) and save them as PNG files; default is 'no'
--print_summary: print the summary of the Fmask result, including the percentage of cloud, shadow, snow, and clear; default is 'no'

Running time (from data loading and data saving; on average):
- UPL (CPU): 8 mins for Sentinel-2; 15 mins for Landsat 4-9


Notes:
- For accuracy evaluation of cloud detection, please set --dcloud=0.
This is because the cloud detection models were developed without any dilation on the cloud mask.
However, we still recommend users apply dilation in practice to reduce omission errors from the cloud edge pixels.

- For accuracy evaluation of cloud shadow detection, please set --dshadow=5.
This is the setup to fill the potential holes generated by the cloud projection, especially when a DEM is integrated to account for double projections.

- For measuring processing time, this script includes the entire workflow—from data loading to data saving—encompassing both cloud and shadow detection.
The processing time may vary depending on the image size and the specific cloud detection model used.
Additionally, ensure that "display_image" is turned off when measuring processing time.

Requirements:
- Python 3.10 or later
- 5GB disk space for package installation
- 20GB memory for running the package

Changelog:
- 5.0.1 (2025-10-23): 
    Algorithms described in detail by Qiu et al., 2026.
    Compared to 5.0.0, mainly added the Sen2Cloud+ dataset for ML training, and reduced image chip size from 512×512 to 256×256 to accommodate this dataset, and shifted image chips to maximize valid pixel coverage and mitigate edge effects in UNet models.
- 5.0.0 (2025-05-07): Initial release.
"""

import os
import sys
from pathlib import Path
import time
import click
sys.path.append(
    str(Path(__file__).parent.parent.joinpath("src"))
)
from fmasklib import Fmask


# Version of the Fmask algorithm
fmask_version = "5.0.1"
    
def fmask_physical(path_image, dcloud=0, dshadow=5, dsnow = 0, destination = None, skip = True, endname="PHY", metadata = False, display_fmask = False, display_image = False, print_summary = False):
    """
    Fmask-physical model for masking clouds and cloud shadows.
    Parameters:
    path_image (str): Path to the input image.
    destination (str, optional): Directory where the output files will be saved. If None, the output will be saved in the same directory as the input image. Default is None.
    skip (bool, optional): If True, skips processing the image when its fmask layer exists. Default is True.
    endname (str, optional): Suffix for the fmask file name. Default is "PHY".
    metadata (bool, optional): If True, saves the model metadata to a CSV file. Default is False.
    display_fmask (bool, optional): If True, displays the Fmask result and saves it as a PNG file. Default is False.
    display_image (bool, optional): If True, displays the color composite images and saves them as PNG files. Default is False.
    print_summary (bool, optional): If True, prints the summary of the Fmask result, inscluding the percentage of cloud, shadow, snow, and clear. Default is False.
    """

    # start the timer
    time_start = time.perf_counter()
    # msg
    print(f"Processing {path_image} with Fmask-physical model")
    # initiate the Fmask object
    fmask = Fmask(path_image, algorithm = "physical", dcloud = dcloud, dshadow = dshadow, dsnow = dsnow)
    # force to alter the destination as required, but it not, the destination will be the same as the image
    if destination is not None:
        fmask.image.destination = destination
    # check if the result already exists
    if skip and fmask.check_mask_existence(endname = endname):
        print(f"Skipping processing of {fmask.image.name} as the result already exists.")
    else:
        # load the image
        fmask.load_image()
        # display the color composite images
        if display_image:
            fmask.display_image(bands = ["nir", "red", "green"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_NRG.png'))
            fmask.display_image(bands = ["swir1", "nir", "red"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_SNR.png'))
            if fmask.image.data.exist("cirrus"):
                fmask.display_image(bands = ["cirrus", "cirrus", "cirrus"],
                                    title = 'Cirrus image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Cirrus.png'))
            if fmask.image.data.exist("tirs1"):
                fmask.display_image(bands = ["tirs1", "tirs1", "tirs1"],
                                    title = 'Tirs1 image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Tirs1.png'))
        # mask the clouds
        fmask.mask_cloud()
        # mask the shadows
        fmask.mask_shadow(postprocess='morphology', min_area=3, potential = "flood", buffer2connect = 3)
        # save the mask
        fmask.save_mask(endname=endname)
        # save the model metadata
        if metadata:
            fmask.save_model_metadata(os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}_meta.csv'), running_time=time.perf_counter() - time_start)
        if print_summary:
            fmask.print_summary()
    # generate fmask figure if required and allowed even if the fmask layer already exists
    if display_fmask:
        fmask.display_fmask(endname=endname,path = os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}.png'), skip = skip)
    # msg
    print(f"Finished with {((time.perf_counter() - time_start)/60): 0.2f} mins")

def fmask_lightgbm(path_image, dcloud=0, dshadow=5, dsnow = 0, destination = None, skip = True, endname="GBM", metadata = False, display_fmask = False, display_image = False, print_summary = False):
    """
    Fmask-LightGBM model for masking clouds and cloud shadows.
    Parameters:
    path_image (str): Path to the input image.
    destination (str, optional): Directory where the output files will be saved. If None, the output will be saved in the same directory as the input image. Default is None.
    skip (bool, optional): If True, skips processing the image when its fmask layer exists. Default is True.
    endname (str, optional): Suffix for the fmask file name. Default is "PHY".
    metadata (bool, optional): If True, saves the model metadata to a CSV file. Default is False.
    display_fmask (bool, optional): If True, displays the Fmask result and saves it as a PNG file. Default is False.
    display_image (bool, optional): If True, displays the color composite images and saves them as PNG files. Default is False.
    print_summary (bool, optional): If True, prints the summary of the Fmask result, inscluding the percentage of cloud, shadow, snow, and clear. Default is False.
    """
    # start the timer
    time_start = time.perf_counter()
    # msg
    print(f"Processing {path_image} with Fmask-LightGBM model")
    # initiate the Fmask object
    fmask = Fmask(path_image, algorithm = "lightgbm", dcloud = dcloud, dshadow = dshadow, dsnow = dsnow)
    # force to alter the destination as required, but it not, the destination will be the same as the image
    if destination is not None:
        fmask.image.destination = destination
    # check if the result already exists
    if skip and fmask.check_mask_existence(endname = endname):
        print(f"Skipping processing of {fmask.image.name} as the result already exists.")
    else:
        # load the image
        fmask.load_image()
        # display the color composite images
        if display_image:
            fmask.display_image(bands = ["nir", "red", "green"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_NRG.png'))
            fmask.display_image(bands = ["swir1", "nir", "red"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_SNR.png'))
            if fmask.image.data.exist("cirrus"):
                fmask.display_image(bands = ["cirrus", "cirrus", "cirrus"],
                                    title = 'Cirrus image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Cirrus.png'))
            if fmask.image.data.exist("tirs1"):
                fmask.display_image(bands = ["tirs1", "tirs1", "tirs1"],
                                    title = 'Tirs1 image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Tirs1.png'))
        # mask the clouds
        fmask.mask_cloud()
        # force to start generate simple masks for snow and water, and the base information for further shadow masking
        fmask.physical.init_constant_filter()
        # mask the shadows
        fmask.mask_shadow(postprocess='none', min_area=3, potential = "flood", buffer2connect = 3) # no post-process, because it replyies on the physical model.
        # save the mask
        fmask.save_mask(endname=endname)
        # save the model metadata
        if metadata:
            fmask.save_model_metadata(os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}_meta.csv'), running_time=time.perf_counter() - time_start)
        if print_summary:
            fmask.print_summary()
    
    # generate fmask figure if required and allowed even if the fmask layer already exists
    if display_fmask:
        fmask.display_fmask(endname=endname,path = os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}.png'), skip = skip)
    # msg
    print(f"Finished with {((time.perf_counter() - time_start)/60): 0.2f} mins")

def fmask_unet(path_image, dcloud=0, dshadow=5, dsnow = 0, destination = None, skip = True, endname="UNT", metadata = False, display_fmask = False, display_image = False, print_summary = False):
    """
    Fmask-UNet model for masking clouds and cloud shadows.
    Parameters:
    path_image (str): Path to the input image.
    destination (str, optional): Directory where the output files will be saved. If None, the output will be saved in the same directory as the input image. Default is None.
    skip (bool, optional): If True, skips processing the image when its fmask layer exists. Default is True.
    endname (str, optional): Suffix for the fmask file name. Default is "PHY".
    metadata (bool, optional): If True, saves the model metadata to a CSV file. Default is False.
    display_fmask (bool, optional): If True, displays the Fmask result and saves it as a PNG file. Default is False.
    display_image (bool, optional): If True, displays the color composite images and saves them as PNG files. Default is False.
    print_summary (bool, optional): If True, prints the summary of the Fmask result, inscluding the percentage of cloud, shadow, snow, and clear. Default is False.
    """
  
    # start the timer
    time_start = time.perf_counter()
    # msg
    print(f"Processing {path_image} with Fmask-UNet model")
    # initiate the Fmask object
    fmask = Fmask(path_image, algorithm = "unet", dcloud = dcloud, dshadow = dshadow, dsnow = dsnow)
    # force to alter the destination as required, but it not, the destination will be the same as the image
    if destination is not None:
        fmask.image.destination = destination
    # check if the result already exists
    if skip and fmask.check_mask_existence(endname = endname):
        print(f"Skipping processing of {fmask.image.name} as the result already exists.")
    else:
        fmask.load_image()
        # display the color composite images
        if display_image:
            fmask.display_image(bands = ["nir", "red", "green"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_NRG.png'))
            fmask.display_image(bands = ["swir1", "nir", "red"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_SNR.png'))
            if fmask.image.data.exist("cirrus"):
                fmask.display_image(bands = ["cirrus", "cirrus", "cirrus"],
                                    title = 'Cirrus image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Cirrus.png'))
            if fmask.image.data.exist("tirs1"):
                fmask.display_image(bands = ["tirs1", "tirs1", "tirs1"],
                                    title = 'Tirs1 image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Tirs1.png'))
        fmask.mask_cloud()
        # force to start generate simple masks for snow and water, and the base information for further shadow masking, only used when the physical model was not used
        fmask.physical.init_constant_filter()
        fmask.mask_shadow(postprocess='none', min_area=0, potential = "flood", buffer2connect = 3) # not we do not exclude the very small cloud objects with less than 3 pixels if we use UNet results as output
        fmask.save_mask(endname=endname)
        if metadata:
            fmask.save_model_metadata(os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}_meta.csv'), running_time=time.perf_counter() - time_start)
        if print_summary:
            fmask.print_summary()
    # generate fmask figure if required and allowed even if the fmask layer already exists
    if display_fmask:
        fmask.display_fmask(endname=endname,path = os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}.png'), skip = skip)

    print(f"Finished with {((time.perf_counter() - time_start)/60): 0.2f} mins")

def fmask_lpl(path_image, dcloud=0, dshadow=5, dsnow = 0, destination = None, skip = True, endname="LPL", metadata = False, display_fmask = False, display_image = False, print_summary = False):
    """
    Fmask-LPL model for masking clouds and cloud shadows.
    Parameters:
    path_image (str): Path to the input image.
    destination (str, optional): Directory where the output files will be saved. If None, the output will be saved in the same directory as the input image. Default is None.
    skip (bool, optional): If True, skips processing the image when its fmask layer exists. Default is True.
    endname (str, optional): Suffix for the fmask file name. Default is "PHY".
    metadata (bool, optional): If True, saves the model metadata to a CSV file. Default is False.
    display_fmask (bool, optional): If True, displays the Fmask result and saves it as a PNG file. Default is False.
    display_image (bool, optional): If True, displays the color composite images and saves them as PNG files. Default is False.
    print_summary (bool, optional): If True, prints the summary of the Fmask result, inscluding the percentage of cloud, shadow, snow, and clear. Default is False.
    """
    # start the timer
    time_start = time.perf_counter()
    # msg
    print(f"Processing {path_image} with Fmask-LPL model")
    # initiate the Fmask object
    time_start = time.perf_counter()
    fmask = Fmask(path_image, algorithm = "interaction", base = "lightgbm", tune = "lightgbm", dcloud = dcloud, dshadow = dshadow, dsnow = dsnow)
    # force to alter the destination as required, but it not, the destination will be the same as the image
    if destination is not None:
        fmask.image.destination = destination
    # check if the result already exists
    if skip and fmask.check_mask_existence(endname = endname):
        print(f"Skipping processing of {fmask.image.name} as the result already exists.")
    else:
        fmask.load_image()
        # display the color composite images
        if display_image:
            fmask.display_image(bands = ["nir", "red", "green"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_NRG.png'))
            fmask.display_image(bands = ["swir1", "nir", "red"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_SNR.png'))
            if fmask.image.data.exist("cirrus"):
                fmask.display_image(bands = ["cirrus", "cirrus", "cirrus"],
                                    title = 'Cirrus image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Cirrus.png'))
            if fmask.image.data.exist("tirs1"):
                fmask.display_image(bands = ["tirs1", "tirs1", "tirs1"],
                                    title = 'Tirs1 image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Tirs1.png'))
        fmask.mask_cloud()
        fmask.mask_shadow(postprocess='morphology', min_area=3, potential = "flood", buffer2connect = 3)
        fmask.save_mask(endname=endname)
        if metadata:
            fmask.save_model_metadata(os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}_meta.csv'), running_time=time.perf_counter() - time_start)
        if print_summary:
            fmask.print_summary()
    # generate fmask figure if required and allowed even if the fmask layer already exists
    if display_fmask:
        fmask.display_fmask(endname=endname,path = os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}.png'), skip = skip)

    print(f"Finished with {((time.perf_counter() - time_start)/60): 0.2f} mins")

def fmask_upu(path_image, dcloud=0, dshadow=5, dsnow = 0, destination = None, skip = True, endname="UPU", metadata = False, display_fmask = False, display_image = False, print_summary = False):
    """
    Fmask-UPU model for masking clouds and cloud shadows.
    Parameters:
    path_image (str): Path to the input image.
    destination (str, optional): Directory where the output files will be saved. If None, the output will be saved in the same directory as the input image. Default is None.
    skip (bool, optional): If True, skips processing the image when its fmask layer exists. Default is True.
    endname (str, optional): Suffix for the fmask file name. Default is "PHY".
    metadata (bool, optional): If True, saves the model metadata to a CSV file. Default is False.
    display_fmask (bool, optional): If True, displays the Fmask result and saves it as a PNG file. Default is False.
    display_image (bool, optional): If True, displays the color composite images and saves them as PNG files. Default is False.
    print_summary (bool, optional): If True, prints the summary of the Fmask result, inscluding the percentage of cloud, shadow, snow, and clear. Default is False.
    """

    # start the timer
    time_start = time.perf_counter()
    # msg
    print(f"Processing {path_image} with Fmask-UPU model")
    fmask = Fmask(path_image, algorithm = "interaction", base = "unet", tune = "unet", dcloud = dcloud, dshadow = dshadow, dsnow = dsnow)
    # force to alter the destination as required, but it not, the destination will be the same as the image
    if destination is not None:
        fmask.image.destination = destination
    # check if the result already exists
    if skip and fmask.check_mask_existence(endname = endname):
        print(f"Skipping processing of {fmask.image.name} as the result already exists.")
    else:
        fmask.load_image()
        if display_image:
            fmask.display_image(bands = ["nir", "red", "green"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_NRG.png'))
            fmask.display_image(bands = ["swir1", "nir", "red"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_SNR.png'))
            if fmask.image.data.exist("cirrus"):
                fmask.display_image(bands = ["cirrus", "cirrus", "cirrus"],
                                    title = 'Cirrus image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Cirrus.png'))
            if fmask.image.data.exist("tirs1"):
                fmask.display_image(bands = ["tirs1", "tirs1", "tirs1"],
                                    title = 'Tirs1 image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Tirs1.png'))
        fmask.mask_cloud()
        fmask.mask_shadow(postprocess='none', min_area=0, potential = "flood", buffer2connect = 3)
        fmask.save_mask(endname=endname)
        if metadata:
            fmask.save_model_metadata(os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}_meta.csv'), running_time=time.perf_counter() - time_start)
        if print_summary:
            fmask.print_summary()
    # generate fmask figure if required and allowed even if the fmask layer already exists
    if display_fmask:
        fmask.display_fmask(endname=endname,path = os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}.png'), skip = skip)

    print(f"Finished with {((time.perf_counter() - time_start)/60): 0.2f} mins")

def fmask_lpu(path_image, dcloud=0, dshadow=5, dsnow = 0, destination = None, skip = True, endname="LPU", metadata = False, display_fmask = False, display_image = False, print_summary = False):
    """
    Fmask-LPU model for masking clouds and cloud shadows.
    Parameters:
    path_image (str): Path to the input image.
    destination (str, optional): Directory where the output files will be saved. If None, the output will be saved in the same directory as the input image. Default is None.
    skip (bool, optional): If True, skips processing the image when its fmask layer exists. Default is True.
    endname (str, optional): Suffix for the fmask file name. Default is "PHY".
    metadata (bool, optional): If True, saves the model metadata to a CSV file. Default is False.
    display_fmask (bool, optional): If True, displays the Fmask result and saves it as a PNG file. Default is False.
    display_image (bool, optional): If True, displays the color composite images and saves them as PNG files. Default is False.
    print_summary (bool, optional): If True, prints the summary of the Fmask result, inscluding the percentage of cloud, shadow, snow, and clear. Default is False.
    """

    # start the timer
    time_start = time.perf_counter()
    # msg
    print(f"Processing {path_image} with Fmask-LPU model")
    fmask = Fmask(path_image, algorithm = "interaction", base = "lightgbm", tune = "unet", dcloud = dcloud, dshadow = dshadow, dsnow = dsnow)
    # force to alter the destination as required, but it not, the destination will be the same as the image
    if destination is not None:
        fmask.image.destination = destination
    # check if the result already exists
    if skip and fmask.check_mask_existence(endname = endname):
        print(f"Skipping processing of {fmask.image.name} as the result already exists.")
    else:
        fmask.load_image()
        if display_image:
            fmask.display_image(bands = ["nir", "red", "green"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_NRG.png'))
            fmask.display_image(bands = ["swir1", "nir", "red"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_SNR.png'))
            if fmask.image.data.exist("cirrus"):
                fmask.display_image(bands = ["cirrus", "cirrus", "cirrus"],
                                    title = 'Cirrus image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Cirrus.png'))
            if fmask.image.data.exist("tirs1"):
                fmask.display_image(bands = ["tirs1", "tirs1", "tirs1"],
                                    title = 'Tirs1 image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Tirs1.png'))
        fmask.mask_cloud()
        fmask.mask_shadow(postprocess='none', min_area=0, potential = "flood", buffer2connect = 3) # no postprocessing for the cloud mask when unet is output
        fmask.save_mask(endname=endname) # save the mask
        if metadata:
            fmask.save_model_metadata(os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}_meta.csv'), running_time=time.perf_counter() - time_start)
        if print_summary:
            fmask.print_summary()
    # generate fmask figure if required and allowed even if the fmask layer already exists
    if display_fmask:
        fmask.display_fmask(endname=endname,path = os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}.png'), skip = skip)

    print(f"Finished with {((time.perf_counter() - time_start)/60): 0.2f} mins")

def fmask_upl(path_image, dcloud=0, dshadow=5, dsnow = 0, destination = None, skip = True, endname="UPL", metadata = False, display_fmask = False, display_image = False, print_summary = False):
    """
    Fmask-UPL model for masking clouds and cloud shadows.
    Parameters:
    path_image (str): Path to the input image.
    destination (str, optional): Directory where the output files will be saved. If None, the output will be saved in the same directory as the input image. Default is None.
    skip (bool, optional): If True, skips processing the image when its fmask layer exists. Default is True.
    endname (str, optional): Suffix for the fmask file name. Default is "PHY".
    metadata (bool, optional): If True, saves the model metadata to a CSV file. Default is False.
    display_fmask (bool, optional): If True, displays the Fmask result and saves it as a PNG file. Default is False.
    display_image (bool, optional): If True, displays the color composite images and saves them as PNG files. Default is False.
    print_summary (bool, optional): If True, prints the summary of the Fmask result, inscluding the percentage of cloud, shadow, snow, and clear. Default is False.
    """
    # start the timer
    time_start = time.perf_counter()
    # msg
    print(f"Processing {path_image} with Fmask-UPL model")
    # initiate the Fmask object
    fmask = Fmask(path_image, algorithm = "interaction", base = "unet", tune = "lightgbm", dcloud = dcloud, dshadow = dshadow, dsnow = dsnow)
    # force to alter the destination as required, but it not, the destination will be the same as the image
    if destination is not None:
        fmask.image.destination = destination
    # check if the result already exists
    if skip and fmask.check_mask_existence(endname = endname):
        print(f"Skipping processing of {fmask.image.name} as the result already exists.")
    else:
        fmask.load_image()
        if display_image:
            fmask.display_image(bands = ["nir", "red", "green"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_NRG.png'))
            fmask.display_image(bands = ["swir1", "nir", "red"],
                                title = 'Color composite image',
                                percentiles = [10, 90],
                                path = os.path.join(fmask.image.destination, fmask.image.name + '_SNR.png'))
            if fmask.image.data.exist("cirrus"):
                fmask.display_image(bands = ["cirrus", "cirrus", "cirrus"],
                                    title = 'Cirrus image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Cirrus.png'))
            if fmask.image.data.exist("tirs1"):
                fmask.display_image(bands = ["tirs1", "tirs1", "tirs1"],
                                    title = 'Tirs1 image',
                                    percentiles = [10, 90],
                                    path = os.path.join(fmask.image.destination, fmask.image.name + '_Tirs1.png'))
        fmask.mask_cloud()
        fmask.mask_shadow(postprocess='unet', min_area=3, potential = "flood", buffer2connect = 3) # unet-based elimination for postpocessing, and also remove the very small cloud objects with less than 3 pixels to reduce peper noises
        fmask.save_mask(endname=endname)
        if metadata:
            fmask.save_model_metadata(os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}_meta.csv'), running_time=time.perf_counter() - time_start)
        if print_summary:
            fmask.print_summary()
    # generate fmask figure if required and allowed even if the fmask layer already exists
    if display_fmask:
        fmask.display_fmask(endname=endname,path = os.path.join(fmask.image.destination, fmask.image.name + f'_{endname}.png'), skip = skip)

    print(f"Finished with {((time.perf_counter() - time_start)/60): 0.2f} mins")

@click.command()
@click.option("--model", "-m", type=str, help="Cloud detection model to use.", default="UPL")
@click.option("--dcloud", "-c", type=int, help="Dilation for cloud mask in pixels", default=3)
@click.option("--dshadow", "-s", type=int, help="Dilation for shadow mask in pixels", default=5)
@click.option("--dsnow", "-n", type=int, help="Dilation for shadow mask in pixels", default=0)
@click.option(
    "--imagepath", "-i",
    type=str,
    help="Directory containing Landsat/Sentinel-2 images. Supports multiple images.",
    default="/gpfs/sharedfs1/zhulab/Shi/ProjectCloudDetectionFmask5/HLSDataset/Landsat/LC08_L1TP_048022_20230713_20230724_02_T1",
)
@click.option(
    "--output", "-o",
    type=str,
    help="Destination directory for results. If not provided, results are saved in the image directory.",
    default="",
)
@click.option("--skip_existing", "-s", type=click.Choice(["yes", "no", "Yes", "No", "YES", "NO"]), help="Skip processing if results already exist (set to 0 to force generation).", default="no")
@click.option("--save_metadata", "-md", type=click.Choice(["yes", "no", "Yes", "No", "YES", "NO"]), help="Save model metadata to a CSV file.", default="no")
@click.option("--display_fmask", "-df", type=click.Choice(["yes", "no", "Yes", "No", "YES", "NO"]), help="Display and save the Fmask result as a PNG file.", default="no")
@click.option("--display_image", "-di", type=click.Choice(["yes", "no", "Yes", "No", "YES", "NO"]), help="Display and save color composite images as PNG files.", default="no")
@click.option("--print_summary", "-ps", type=click.Choice(["yes", "no", "Yes", "No", "YES", "NO"]), help="Print Fmask summary including cloud, shadow, snow, and clear percentages.", default="no")
def main(model, dcloud, dshadow, dsnow, imagepath, output, skip_existing, save_metadata, display_fmask, display_image, print_summary) -> None:
    print("************************************************")
    print(f"Starting Fmask {fmask_version} with dilating {dcloud} for cloud, {dshadow} for shadow, and {dsnow} for snow")

    # setup the output directory as none and use the default image path if not provided
    if output == "":
        output = None
    skip_existing = True if skip_existing.lower() == "yes" else False
    save_metadata = True if save_metadata.lower() == "yes" else False
    display_fmask = True if display_fmask.lower() == "yes" else False
    display_image = True if display_image.lower() == "yes" else False
    print_summary = True if print_summary.lower() == "yes" else False

    # check the model name and run the corresponding model
    if model.upper() == 'UPL': # UNet-Physical-LightGBM recommnad for landsat 8-9 and sentinel 2
        fmask_upl(path_image = imagepath, dcloud=dcloud, dshadow=dshadow, dsnow=dsnow,
                  destination = output, skip = skip_existing, 
                  metadata = save_metadata, display_fmask = display_fmask, display_image = display_image, print_summary = print_summary)
    elif model.upper() == 'LPL': # LightGBM-Physical-LightGBM recommnad for landsat 4-7
        fmask_lpl(path_image = imagepath, dcloud=dcloud, dshadow=dshadow, dsnow=dsnow,
                  destination = output, skip = skip_existing, 
                  metadata = save_metadata, display_fmask = display_fmask, display_image = display_image, print_summary = print_summary)
    elif model.upper() == 'PHY': # Fmask 4.6
        fmask_physical(path_image = imagepath, dcloud=dcloud, dshadow=dshadow, dsnow=dsnow,
                  destination = output, skip = skip_existing, 
                  metadata = save_metadata, display_fmask = display_fmask, display_image = display_image, print_summary = print_summary)
    elif model.upper() == 'GBM': # LightGBM
        fmask_lightgbm(path_image = imagepath, dcloud=dcloud, dshadow=dshadow, dsnow=dsnow,
                  destination = output, skip = skip_existing, 
                  metadata = save_metadata, display_fmask = display_fmask, display_image = display_image, print_summary = print_summary)
    elif model.upper() == 'UNT': # UNet
        fmask_unet(path_image = imagepath, dcloud=dcloud, dshadow=dshadow, dsnow=dsnow,
                   destination = output, skip = skip_existing, 
                   metadata = save_metadata, display_fmask = display_fmask, display_image = display_image, print_summary = print_summary)
    elif model.upper() == 'UPU': # UNet-Physical-UNet
        fmask_upu(path_image = imagepath, dcloud=dcloud, dshadow=dshadow, dsnow=dsnow,
                  destination = output, skip = skip_existing, 
                  metadata = save_metadata, display_fmask = display_fmask, display_image = display_image, print_summary = print_summary)
    elif model.upper() == 'LPU': # LightGBM-Physical-UNet
        fmask_lpu(path_image = imagepath, dcloud=dcloud, dshadow=dshadow, dsnow=dsnow,
                  destination = output, skip = skip_existing, 
                  metadata = save_metadata, display_fmask = display_fmask, display_image = display_image, print_summary = print_summary)
    else:
        print(f"Model {model} is not supported.")
        return

# main port to run the fmask by command line
if __name__ == "__main__":
    main()